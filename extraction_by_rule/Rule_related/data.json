[
  {
    "id": 1,
    "title": "8 Subnetwork dependent functions\n",
    "text": "The Subnetwork Dependent Functions mask the characteristics of the different kinds of Subnetworks from the Subnetwork Independent Routeing Functions. The only two types of circuits the Subnetwork Independent Functions recognise are broadcast and general topology.\nThe Subnetwork Dependent Functions include:\n- The use of the ISO 8473 Subnetwork Dependent Con-vergence Functions (SNDCF) so that this protocol may transmit and receive PDUs over the same subnetwork types, using the same techniques, as does ISO 8473.\n- Co-ordination with the operation of the ES\u2013IS protocol (ISO 9542) in order to determine the Network layer addresses (and on Broadcast subnetworks, the subnetwork point of attachment address) and identities (End System or Intermediate System) of all adjacent neighbours. This information is held in the Adjacency database. It is used to construct Link State PDUs.\n- The exchange of IIH PDUs. While it is possible for an Intermediate System to identify that it has an Intermediate System neighbour by the receipt of an ISO 9542 ISH PDU, there is no provision within ISO 9542 to indicate whether the neighbour is a Level 1 or a Level 2 Intermediate System. Specific PDUs (LAN Level 1, LAN Level 2 and Point-to-point  IIH PDUs) are defined to convey this information.\n",
    "extraction": []
  },
  {
    "id": 2,
    "title": "8.1 Multi-destination circuits on ISs at a domain boundary\n",
    "text": "Routeing information (e.g. Link State PDUs) is not exchanged across a routeing domain boundary. All routeing information relating to a circuit connected to another routeing domain is therefore entered via the Reachable Address managed objects.  This information is disseminated to the rest of the routeing domain via Link State PDUs as described in 7.3.3.2. This has the effect of causing NPDUs destined for NSAPs which are included in the addressPrefix of the Reachable Addresses to be relayed to that Intermediate System at the domain boundary. On receipt of such an NPDU the Intermediate system shall forward it onto the appropriate circuit, based on its own Link State information. However in the case of multi-destination subnetworks (such as an ISO 8208 subnetwork using Dynamic Assignment, a broadcast subnetwork, or a connectionless subnetwork) it is necessary to ascertain additional subnetwork dependent addressing information in order to forward the NPDU to a suitable SNPA. (This may be the target End system or an Intermediate system within the other domain.)\nIn general the SNPA address to which an NPDU is to be forwarded can be derived from the destination NSAP of the NPDU. It may be possible to perform some algorithmic manipulation of the NSAP address in order to derive the SNPA address. However there may be some NSAPs where this is not possible. In these cases it is necessary to have pre-configured information relating an address prefix to a particular SNPA address.\nThis is achieved by additional information contained in the reachable address managed object. The mappingType attribute specifies the means by which next hop subnetwork addressing information can be derived for NPDUs forwarded based upon a given address prefix. The mappingType attribute may be specified as:\nexplicit \u2014 The SNPA address or set of SNPA addresses is manually pre-configured as an attribute of the reachable address managed object.\nextractIDI \u2014 The SNPA is embedded in the IDI of the destination NSAP address according to the format and encoding rules of ISO 8348. This SNPA extraction algorithm can be used in conjunction with destination addresses from the X.121, F.69, E.163, and E.164 addressing subdomains.\nextractDSP \u2014 All or a suffix of the SNPA is embedded in the DSP of the destination address. This SNPA extraction algorithm requires manual pre-configuration of sNPAMask and sNPAPrefix attributes of the reachable address managed object. The sNPAMask attribute is a bit mask with 1s indicating the location of the SNPA (suffix) within the destination NSAP DSP. The part of the SNPA extracted from the NSAP is appended to the sNPAPrefix to form the next hop subnetwork addressing information.\nAn example of a set of Reachable Addresses is shown in table 3. The table is interpreted as follows:\na) For the ISO DCC prefix 39 123, use the SNPA address X.\nb) For the X.121 IDI address prefix 37 aaaaa, do not use aaaaa, but use B instead.\nc) For all IDPs based on SNPAs with DNIC D (i.e. with address prefix 37 D), use the address Y (which would probably be a gateway to a subnetwork with DNIC D).\nd) For any other X.121 IDI (i.e. address prefix 37) \u2013 use the SNPA whose address is used as the IDI.\ne) For the ISO ICD prefix 47 0005 C0 use the SNPA address formed by concatenating Z with next 6 octets of the DSP following the 47 0005 C0 prefix.\nf) Anything else (\u201c*\u201d in table 3) \u2013 use one of the SNPA addresses R, S or T. These would typically be the SNPA addresses of Level 2 Intermediate Systems through which any other addresses could potentially be reached.\n",
    "extraction": []
  },
  {
    "id": 3,
    "title": "8.2 Point-to-point subnetworks\n",
    "text": "This clause describes the identification of neighbours on both point-to-point links and Static circuits.\nThe IS shall operate the ISO 9542 protocol, shall be able to receive ISO 9542 ISH PDUs from other ISs, and shall store the information so obtained in the adjacency database.\n",
    "extraction": []
  },
  {
    "id": 4,
    "title": "8.2.1 Receipt of ESH PDUs \u2014 database of end systems\n",
    "text": "An IS shall enter an End system into the adjacency database when an ESH PDU is received on a circuit. If an ESH PDU is received on the same circuit, but with a different NSAP address, the new address shall be added to the adjacency, with a separate timer. A single ESH PDU may contain more than one NSAP address. When a new data link address or NSAP address is added to the adjacency database, the IS shall generate an adjacencyStateChange (Up) event on that adjacency.\nThe IS shall set a timer for the value of Holding Time in the received ESH PDU. If another ESH PDU is not received from the ES before that timer expires, the ES shall be purged from the database, provided that the Subnetwork Independent Functions associated with initialising the adjacency have been completed. Otherwise the IS shall clear the adjacency as soon as those functions are completed.\nTable 3 \u2013 Example of reachable address information\nAddress Prefix\nMapping Type\nSNPA Address\n39 123\nExplicit\nX\n37 aaaa\nExplicit\nB\n37 D\nExplicit\nY\n37\nextractIDI\nExtract X.121 SNPA addrss from NSAP IDI\n47 00055 C0\nextractDSP\nsNPAPrefix=Z sNPAMask=000000000FFFFFFFFFFFF\n*\nExplicit\nR,S,T\nWhen the adjacency is cleared, the Subnetwork Independent Functions shall be informed of an adjacencyStateChange (Down) event, and the adjacency can be reused after the Sub network Independent Functions associated with bringing down the adjacency have been completed.\n",
    "extraction": [
      {
        "id": 0,
        "text": "When a new data link address or NSAP address is added to the adjacency database, the IS shall generate an adjacencyStateChange (Up) event on that adjacency.",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "When a new data link address or NSAP address is added to the adjacency database"
        ],
        "new_state": [
          "adjacencyStateChange (Up)"
        ]
      }
    ]
  },
  {
    "id": 5,
    "title": "8.2.2 Receiving ISH PDUs by an intermediate system\n",
    "text": "On receipt of an ISH PDU by an Intermediate System, the IS shall create an adjacency (with adjacencyState \u201cInitialising\u201d and neighbourSystemType \u201cUnknown\u201d), if one does not already exist, and then perform the following actions:\na) If the adjacencyState is \u201cUp\u201d and the ID portion of the NET field in the ISH PDU does not match the neigh-bourID of the adjacency then the IS shall\n1) generate an adjacencyStateChange (Down) event;\n2) delete the adjacency; and\n3) create a new adjacency with:\ni. adjacencyState set to \u201cInitialising\u201d, and\nii. neighbourSystemType set to \u201cUnknown\u201d.\n4) perform the following actions.\nb) If the adjacencyState is \u201cInitialising\u201d, and the neighbourSystemType status is \u201cIntermediate System\u201d, the ISH PDU shall be ignored.\nc) If the adjacencyState is \u201cInitialising\u201d and the neighbourSystemType status is not \u201cIntermediate System\u201d, a point-to- point IIH PDU shall be transmitted as described in 8.2.4.\nd) The neighbourSystemType shall be set to \u201cIntermediate System\u201d indicating that the neighbour is an Intermediate system, but the type (L1 or L2) is, as yet, Unknown.\ne) The circuitType field shall be set according to Table 4.\n",
    "extraction": [
      {
        "id": 0,
        "text": "if one does not already exist, and then perform the following actions: a) If the adjacencyState is \u201cUp\u201d and the ID portion of the NET field in the ISH PDU does not match the neigh-bourID of the adjacency then the IS shall 1) generate an adjacencyStateChange (Down) event; 2) delete the adjacency; and 3) create a new adjacency with: i) adjacencyState set to \u201cInitialising\u201d, and ii) neighbourSystemType set to \u201cUnknown\u201d.",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "If the adjacencyState is \u201cUp\u201d and the ID portion of the NET field in the ISH PDU does not match the neigh-bourID of the adjacency"
        ],
        "new_state": [
          "Initialising"
        ]
      }
    ]
  },
  {
    "id": 6,
    "title": "8.2.3 Sending ISH PDUs by an Intermediate System\n",
    "text": "An Intermediate System shall cause ISO 9542 to send ISH PDUs whenever a point-to-point circuit is either first enabled or the adjacency on the circuit transitions to the Down state. ISH PDUs shall continue to be sent periodically at an interval specified by the ISO 9542 Intermediate System Configuration Timer until an adjacency on the circuit transitions to the Up state.\nISH PDUs are not required to be sent when an adjacency on the circuit is in the Up state and it is suggested that an implementation not send them in this state. ISH PDUs received on a point-to-point circuit when an adjacency is in the Up state should be ignored.\n",
    "extraction": []
  },
  {
    "id": 7,
    "title": "8.2.4 Sending point-to-point IIH PDUs\n",
    "text": "An IS shall send Point-to-Point IIH PDUs on those Point-to-Point circuits whose externalDomain attribute is set \u201cFalse\u201d. The IIH PDU shall be sent when:\na) the IS receives an ISH PDU\nb) whenever iSISHelloTimer expires\nThe iSISHelloTimer shall be (re)started upon transmission of the IIH PDU. The IIH shall be constructed and transmitted as follows:\na) The Circuit Type field shall be set according to table 4.\nb) The Local Circuit ID field shall be set to a value assigned by this Intermediate system when the circuit is created. This value shall be unique among all the circuits of this Intermediate system.\nc) The first Point-to-point IIH PDU (i.e. that transmitted as a result of receiving an ISH PDU, rather than as a result of timer expiration) shall be padded (with trailing PAD option fields containing arbitrary valued octets) so that the SNSDU containing the IIH PDU has a length of at least maxsize - 1 octets1) ) where maxsize is the maximum of\n1) dataLinkBlocksize\n2) originatingL1LSPBufferSize\n3) originatingL2LSPBufferSize\nThis is done to ensure that an adjacency will only be formed between systems which are capable of exchanging PDUs of length up to maxsize octets. In the absence of this check, it would be possible for an adjacency to exist with a lower maximum block size, with the result that some LSPs and SNPs (i.e. those longer than this maximum, but less than maxsize) would not be exchanged.\nNOTE 46 It is necessary for the manager to ensure that the value of dataLinkBlocksize on a circuit which will be used to form an Intermediate system to Intermediate system adjacency is set to a value greater than or equal to the maximum of the LSPBufferSize characteristics listed above. If this is not done, the adjacency will fail to initialise. It is not possible to enforce this requirement, since it is not known until initialisation time whether or not the neighbour on the circuit will be an End system or an Intermediate system. An End system adjacency may operate with a lower value for dataLinkBlocksize.\nd) If the value of the circuitTransmitPassword for the circuit is non-null, then the IS shall include the Authentication Information field in the transmitted IIH PDU, indicating an Authentication Type of \u201cPassword\u201d and containing the circuitTransmitPassword as the authentication value.\n1) The minimum length of PAD which may be added is 2 octets, since that is the size of the option header. Where possible the PDU should be padded to maxsize, but if the PDU length is maxsize \u2013 1 octets no passing is possible (or required).\nTable 4 \u2013 Setting the value of the circuit type field\niSType\nCircuit manualL2OnlyMode\nCircuit Type Field\nLevel 1\n--\nLevel 1 only (1)\nLevel 2\n\u201cTrue\u201d\nLevel 2 only (2)\nLevel 2\n\u201cFalse\u201d\nLevel 1 and 2 (3)\n",
    "extraction": []
  },
  {
    "id": 8,
    "title": "8.2.5 Receiving point-to-point IIH PDUs\n",
    "text": "",
    "extraction": []
  },
  {
    "id": 9,
    "title": "8.2.5.1 PDU acceptance tests\n",
    "text": "On receipt of a Point-to-Point IIH PDU, perform the following PDU acceptance tests:\na) If the IIH PDU was received over a circuit whose externalDomain attribute is set \u201cTrue\u201d, the IS shall discard the PDU.\nb) If the ID Length field of the PDU is not equal to the value of the IS\u2019s routeingDomainIDLength, the PDU shall be discarded and an iDFieldLengthMismatch event generated.\nc) If the value of circuitTransmitPassword or the set of circuitReceivePasswords for this circuit is non-null, then perform the following tests:\n1) If the PDU does not contain the Authentication In-formation field then the PDU shall be discarded and an\nauthenticationFailure event generated.\n2) \u201cIf the PDU contains the Authentication Informa-tion field, but the Authentication Type is not equal to \u201cPassword\u201d, then:\ni. If the IS implements the authentication procedure indicated by the Authentication Type whether the IS accepts or ignores the PDU is outside the scope of this International Standard.\nii. If the IS does not implement the authentication procedure indicated by the Authentication Type then the IS shall ignore the PDU and generate an authenticationFailure event.\u201d\n3) Otherwise, the IS shall compare the password in the received PDU with the passwords in the set of circuitReceivePasswords for the circuit on which the PDU was received. If the value in the PDU matches any of these passwords, the IS shall accept the PDU for further processing. If the value in the PDU does not match any of the circuit-ReceivePasswords, then the IS shall ignore the PDU and generate an authenticationFailure event.\n",
    "extraction": []
  },
  {
    "id": 10,
    "title": "8.2.5.2 IIH PDU Processing\n",
    "text": "When a Point-to-point IIH PDU is received by an Intermediate system, the area addresses of the two Intermediate Systems shall be compared to ascertain the validity of the adjacency. If the two Intermediate systems have an area address in common and matching values for maximumAreaAddresses, the adjacency is valid for all combinations of Intermediate system types (except where a Level 1 Intermediate system is con-nected to a Level 2 Intermediate system with manualL2OnlyMode set \u201cTrue\u201d). However, if they have no area address in common, the adjacency is only valid if both Intermediate systems are    Level 2, and the IS shall mark the adjacency as Level 2 Only. This is described in more detail below.\nOn receipt of a Point-to-point IIH PDU, each of the Area Addresses from the PDU shall be compared with the set of area addresses in the manualAreaAddresses attribute.\na) If a match is detected between any pair the following actions are taken.\n1) If the Maximum Area Addresses field of the PDU is not equal to the value of the IS\u2019s maximumAreaAddresses then the PDU shall be discarded and a maximumAreaAddresses-Mismatch event generated, unless the IS only implements a value of three for maximumArea-Addresses, in which case this check may be omitted.\n2) If the local system is of iSType \u201cL1IntermediateSystem\u201d the IS shall perform the action indicated by table 5.\n3) If the local system is of iSType \u201cL2Intermediate-System\u201d and the Circuit manualL2OnlyMode has the value \u201cFalse\u201d, the IS shall perform the action indicated by table 6.\nTable 5 \u2013 Level 1 state table for matching areas\nCircuit Type (1)\nAdjacency Usage\nnone (2)\nLevel 1 (3)\nLevel 1 only\nUp (4) L1 (5)\nAccept\nLevel 2 only\nReject (7) (Wrong system)\nDown (6) (Wrong system)\nLevel 1 and 2\nUp (4) L1 (5)\nAccept\n(1) The value of the Circuit Type field in the received PDU.\n(2) The adjacency is not in adjacencyState \u201cUp\u201d.\n(3) adjacencyUsage is \u201cLevel 1\u201d\n(4) The adjacency is accepted and an adjacencyStateChange (Up)\u201d event is generated. If the Adjacency neighbourSystemType was \u201cUnknown\u201d (i.e. no ISH PDU has yet been received), a point-to-point IIH PDU is also transmitted.\n(5) The adjacencyUsage status is set to \u201cLevel 1\u201d\n(6) An adjacencyStateChange (Down)\u201d event is generated, with the specified reason, and the adjacency deleted.\n(7) A wrongSystemType event is generated.\n4) If the local system is of iSType \u201cL2Intermediate-System\u201d and the Circuit manualL2OnlyMode has the value \u201cTrue\u201d, the IS shall perform the action indicated by table 7.\nb) If a no match is detected between any pair, the following actions shall be performed.\n1) If the local system is of iSType \u201cL1Intermediate-System\u201dand the adjacency is not in state \u201cUp\u201d, the IS shall delete the adjacency (if any) and generate an areaMismatch event.\n2) If the local system is of iSType \u201cL1IntermediateSystem\u201d and the adjacency is in state \u201cUp\u201d, the IS shall delete the adjacency and generate an adjacencyStateChange (Down \u2013 Area Mismatch)\u201d event .\n3) If the local system is of iSType \u201cL2IntermediateSystem\u201d the IS shall perform the action indicated by table 8 (irrespective of the value of manualL2OnlyMode for this circuit).\nc) If the action taken is \u201cUp\u201d, as detailed in the tables referenced above, the IS shall compare the Source ID field of the  PDU with the local systemID.\n1) If the local Intermediate system has the higher Source ID, the IS shall set the Circuit CircuitID status to the concatenation of the local systemID and the Local Circuit ID (as sent in the Local Circuit ID field of point-to-point IIH PDUs from this Intermediate System) of this circuit.\n2) If the remote Intermediate system has the higher Source ID, the IS shall set the Circuit CircuitID status to the concatenation of the remote system\u2019s Source ID (from the Source ID field of the PDU), and the remote system\u2019s Local Circuit ID (from the Local Circuit ID field of the PDU).\n3) If the two source IDs are the same (i.e. the system is initialising to itself), the local systemID is used.\nNOTE 47 The circuitID status is not used to generate the Local Circuit ID to be sent in the Local Circuit ID field of IIH PDUs transmitted by this Intermediate system. The Local Circuit ID value is assigned once, when the circuit is created and is not subsequently changed.\nd) If the action taken is \u201cAccept\u201d and the neighbor System ID in the adjacency does not match the source ID field from the PDU, or the new value computed for the circuit ID is different from that in the existing adjacency, the IS shall\n1) generate an adjacencyStateChange (Down) event, and\n2) delete the adjacency.\ne) If the action taken is \u201cUp\u201d or \u201cAccept\u201d the IS shall\n1) copy the adjacency areaAddressesOfNeighbour entries from the Area Addresses field of the PDU,\n2) set the holdingTimer to the value of the Holding Time field from the PDU, and\n3) set the neighbourSystemID to the value of the Source ID field from the PDU.\nTable 6 \u2013 Level 2 state table for matching areas\nCircuit Type (1)\nAdjacency Usage\nnone (2)\nLevel 1 (3)\nLevel 1 and 2 (4)\nLevel 2\nLevel 1 only\nUp (6) L1 (7)\nAccept\nDown (8) (Wrong system)\nDown (8) (Wrong system)\nLevel 2 only\nUp (6) L2O (9)\nDown (8) (Wrong system)\nDown (6) (Wrong system)\nAccept\nLevel 1 and 2\nUp (6) L2 (10)\nDown (8) (Wrong system)\nAccept\nDown (8) (Wrong system)\n(1) The value of the Circuit Type field in the received PDU.\n(2) The adjacency is not in adjacencyState \u201cUp\u201d.\n(3) The adjacency is in state \u201cUp\u201d and the Adjacency adjacencyUsage is \u201cLevel 1\u201d.\n(4) The adjacency is in state \u201cUp\u201d and the Adjacency adjacencyUsage is \u201cLevel 1 and 2\u201d.\n(5) The adjacency is in state \u201cUp\u201d and the Adjacency adjacencyUsage is \u201cLevel 2\u201d.\n(6) The adjacency is accepted and an adjacencyStateChange (Up)\u201d event is generated. If the Adjacency neighbourSystemType was \u201cUnknown\u201d (i.e. no ISH PDU has yet been received), a point-to-point IIH PDU is also transmitted.\n(7) The adjacencyUsage status is set to \u201cLevel 1\u201d\n(8) An adjacencyStateChange (Down)\u201d event is generated, with the specified reason, and the adjacency deleted.\n(9) The adjacencyUsage is set to \u201cLevel 2\u201d\n(10) The adjacencyUsage is set to \u201cLevel 1 and 2\u201d.\nTable 7 \u2013 Level 2 only state table for matching areas\nCircuit Type (1)\nAdjacency Usage\nnone (2)\nLevel 1 and 2 (3)\nLevel 2 (4)\nLevel 1 only\nReject (5) (Wrong system)\nDown (6) (Wrong system)\nDown (6) (Wrong system)\nLevel 2 only\nUp (7) L2O (8)\nDown (6) (Wrong system)\nAccept\nLevel 1 and 2\nUp (7) L2O (8)\nDown (6) (Wrong system)\nAccept\n(1) The value of the Circuit Type field in the received PDU.\n(2) The adjacency is not in adjacencyState \u201cUp\u201d.\n(3) The adjacency is in state \u201cUp\u201d and the adjacencyUsage is \u201cLevel 1 and 2\u201d.\n(4) The adjacency is in adjacencyState \u201cUp\u201d and the adjacencyUsage is \u201cLevel 2.\n(5) A wrongSystemType event is generated.\n(6) An adjacencyStateChange (Down)\u201d event is generated, with the specified reason, and the adjacency deleted.\n(7) The adjacency is accepted and an adjacencyStateChange (Up)\u201d event is generated. If the Adjacency neighbourSystemType was \u201cUnknown\u201d (i.e. no ISH PDU has yet been received), a point-to-point IIH PDU is also transmitted.\n(8) The adjacencyUsage status is set to \u201cLevel 2\u201d\n",
    "extraction": [
      {
        "id": 0,
        "text": "If the local system is of iSType \u201cL1IntermediateSystem\u201d and the adjacency is in state \u201cUp\u201d, the IS shall delete the adjacency and generate an adjacencyStateChange (Down \u2013 Area Mismatch)\u201d event .",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "If the local system is of iSType \u201cL1IntermediateSystem\u201d and the adjacency is in state \u201cUp\u201d"
        ],
        "new_state": [
          "adjacencyStateChange (Down \u2013 Area Mismatch)"
        ]
      },
      {
        "id": 1,
        "text": "If the action taken is \u201cAccept\u201d and the neighbor System ID in the adjacency does not match the source ID field from the PDU, or the new value computed for the circuit ID is different from that in the existing adjacency, the IS shall 1) generate an adjacencyStateChange (Down) event, and 2) delete the adjacency.",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "If the action taken is \u201cAccept\u201d and the neighbor System ID in the adjacency does not match the source ID field from the PDU, or the new value computed for the circuit ID is different from that in the existing adjacency"
        ],
        "new_state": [
          "adjacencyStateChange (Down)"
        ]
      }
    ]
  },
  {
    "id": 11,
    "title": "8.2.6 Monitoring point-to-point adjacencies\n",
    "text": "The IS shall keep a holding time (adjacency holdingTimer) for the point-to-point adjacency. The value of the holdingTimer shall be set to the holding time as reported in the Holding Time field of the Pt-Pt IIH PDU. If a neighbour is not heard from in that time, the IS shall\na) purge it from the database; and\nb) generate an adjacencyStateChange (Down) event.\n",
    "extraction": [
      {
        "id": 0,
        "text": "If a neighbour is not heard from in that time, the IS shall a) purge it from the database; and b) generate an adjacencyStateChange (Down) event.",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "If a neighbour is not heard from in that time"
        ],
        "new_state": [
          "adjacencyStateChange (Down)"
        ]
      }
    ]
  },
  {
    "id": 12,
    "title": "8.3 ISO 8208 subnetworks\n",
    "text": "",
    "extraction": []
  },
  {
    "id": 13,
    "title": "8.3.1 Network layer protocols\n",
    "text": "The way in which the underlying service assumed by ISO 8473 is provided for ISO 8208 subnetworks is described in clause 8 of ISO 8473. This defines a set of Subnetwork Dependent Convergence Functions (SNDCFs) that relate the service provided by specific individual ISO International Standard subnetworks to the abstract \u201cunderlying service\u201d defined in 5.5 of ISO 8473. In particular 8.4.3 describes the Subnetwork Dependent Convergence Functions used with ISO 8208 Subnetworks.\nTable 8 \u2013 Level 2 state table for non-matching areas\nCircuit Type (1)\nAdjacency Usage\nnone (2)\nLevel 1 (3)\nLevel 1 and 2 (4)\nLevel 2 (5)\nLevel 1 only\nReject (6) (Area Mismatch)\nDown (7) (Area Mismatch)\nDown (7) (Wrong system)\nDown (7) (Wrong system)\nLevel 2 only\nUp (8) L2O (9)\nDown (7) (Wrong system)\nDown (7) (Wrong system)\nAccept\nLevel 1 and 2\nUp (8) L2O (9)\nDown (7) (Wrong system)\nDown (7) (Area Mismatch)\nAccept\n(1) The value of the Circuit Type field in the received PDU.\n(2) The adjacency is not in adjacencyState \u201cUp\u201d.\n(3) The adjacency is in adjacencyState \u201cUp\u201d and the Adjacency adjacencyUsage is \u201cLevel 1\u201d.\n(4) The adjacency is in adjacencyState \u201cUp\u201d and the Adjacency adjacencyUsage is \u201cLevel 1 and 2\u201d.\n(5) The adjacency is in adjacencyState \u201cUp\u201d and the Adjacency adjacencyUsage is \u201cLevel 2\u201d.\n(6) An areaMismatch event is generated.\n(7) An adjacencyStateChange (Down)\u201d event is generated, with the specified reason, and the adjacency deleted.\n(8) The adjacency is accepted and an adjacencyStateChange (Up)\u201d event is generated. If the Adjacency neighbourSystemType was \u201cUnknown\u201d (i.e. no ISH PDU has yet been received), a point-to-point IIH PDU is also transmitted.\n(9) The adjacencyUsage is set to \u201cLevel 2\u201d\n",
    "extraction": []
  },
  {
    "id": 14,
    "title": "8.3.2 SVC establishment\n",
    "text": "",
    "extraction": []
  },
  {
    "id": 15,
    "title": "8.3.2.1 Use of ISO 8473 subnetwork dependent convergence functions\n",
    "text": "SVCs shall be established according to the procedures defined in the ISO 8208 Subnetwork Dependent Convergence Functions of ISO 8473 (this may be on system management action or on arrival of data depending on the type of circuit). The Call Request shall contain a Protocol Discriminator specifying ISO 8473 in the first octet of Call Userdata.\nIn the case of a static circuit, an SVC shall be established only upon system management action. The IS shall use\nneighbourSNPAAddress as the called SNPA address.\nIn the case of a DA circuit, the call establishment procedures are initiated by the arrival of traffic for the circuit.\n",
    "extraction": []
  },
  {
    "id": 16,
    "title": "8.3.2.2 Dynamically assigned circuits\n",
    "text": "A dynamically assigned circuit has multiple adjacencies, and can therefore establish SVCs to multiple SNPAs. There are several methods that can be used by an Intermediate system to derive the SNPA address to which a call is to be established when an NPDU is to be forwarded over an ISO 8208 subnetwork. These include the following:\n-\t\tIn some instances, the SNPA address to which a call is to be established can be derived from the NSAP to which an NPDU is to be forwarded.\nIn the case where all the NSAPs accessible over the ISO 8208 subnetwork have IDIs which are their SNPA addresses, the correct SNPA can be derived by extracting the IDI, using the \u201cextractIDI\u201d mapping type described in 8.1.\nOther scenarios may also permit the extraction of the SNPA by examining other parts of the NSAP address. In these cases the \u201cextractDSP\u201d mapping type may be used as described in 8.1.\nExamples of the above methods are illustrated in table 3.\n-  In other cases, such as when the IDI refers to some other SNPA address which is suboptimally connected to the target   NSAP (or even not connected at all), or when the IDP does not contain an X.121 address at all (e.g. the ISO DCC address plan), a method not relying upon information in the destination NSAP address must be used.\nIf it is feasible for the IS to maintain the correspondence between an address prefix and an SNPA (via the Reachable Address managed object) then the \u201cexplicit\u201d mapping type may be used as described in 8.1. This may not always be desirable because of the need to administer this information individually in each affected Intermediate system.\nIf a SNARE is available on the subnetwork, then the IS may invoke the appropriate SNARE functions to obtain the  desired SNPA address from the NSAP address in the NPDU to be forwarded.\nThis is achieved, as described in 8.1, by additional information contained in the reachableAddress managed object. The address extraction algorithm may be specified to extract the IDI or DSP portion where the desired portion of the destination NSAP address is the required X.121 address. An example of a set of Reachable Addresses is shown in table 3.\nNOTE 48 If a DA circuit is defined with a reachable address prefix which includes the addresses reachable over a STATIC circuit, the  cost(s) for the DA circuit must be greater than those of the STATIC circuit. If this is not the case, the DA circuit may be used to establish a call to the remote SNPA supporting the STATIC circuit, which would then (wrongly) assume it was the STATIC circuit.\n",
    "extraction": []
  },
  {
    "id": 17,
    "title": "8.3.2.3 Initiating calls (level 2 Intermediate systems)\n",
    "text": "When an NPDU is to be forwarded on a dynamically assigned circuit, for destination NSAP address D, the IS shall\na) Calculate D\u2019s subnetwork address, either as explicitly stated in the reachable address prefix, or as extracted from the destination NSAP address.\n1) If this system is an ES and there is an entry in the RedirectCache or ReversePathCache for D, use the subnetwork address in the cache entry.\n2) If this system is an ES or Level 2 Intermediate system, and the address matches one of the listed reachable address prefixes (including \u201c*\u201d, if present), the subnetwork address is that specified according to the mappingType attribute (either \u201cexplicit\u201d, indicating that the set of addresses in the sNPAAddresses attribute of that Reachable Address are to be used, or \u201cAlgorithm\u201d, indicating that it is to be extracted from the destination NSAP address using the specified algorithm). If multiple SNPA addresses are specified, and there is already an adjacency up to one of those SNPA addresses, then choose that subnetwork address, otherwise choose the subnetwork address with the oldest timestamp as described in 8.3.2.4.\n3) If the address does not match one of the listed reachable address prefixes (and there is no \u201c*\u201d entry), invoke the ISO 8473 Discard PDU function.\nb) Scan the adjacencies for one already open to D\u2019s subnetwork ddress (i.e. reserveTimer has not yet expired). If one is found, transmit the NPDU on that adjacency.\nc) If no adjacency has a call established to the required subnetwork ddress, but there is a free adjacency, attempt to etablish the call using that subnetwork address.\nd) If there is no free adjacency invoke the ISO 8473 Discard PDU function.\nNOTE 49 Where possible, when an adjacency is reserved (when an SVC has been cleared as a result of the idleTimer expiring, but the reserveTimer has not yet expired), resources within the subnetwork service provider should be reserved, in order to minimise the probability that the adjacencywill not be able to initiate a call when required.\n",
    "extraction": []
  },
  {
    "id": 18,
    "title": "8.3.2.4 Call attempt failures\n",
    "text": "The Reachable Address managed objects may contain a set of SNPA addresses, each of which has an associated timestamp. The timestamps shall be initialised to \u201cinfinitely old\u201d.\nSome of the SNPAs in this set may be unreachable. If a call attempt fails to one of the SNPA addresses listed, the IS shall mark that entry in the list with the time of the latest failed attempt. When an SNPA address is to be chosen from the list, the IS shall choose the one with the oldest timestamp , unless the oldest timestamp is more recent than recallTimer. If the oldest  timestamp is more recent than recallTimer, all SNPAs in the set shall be assumed temporarily unreachable and no call attempt is made. The IS shall instead invoke the ISO 8473 Discard PDU function.\nWhen attempting to establish a connection to a single specific subnetwork address (not through one of a set of SNPA addresses), if a call attempt to a particular SNPA address, A, fails for any reason, the IS shall invoke the ISO 8473 Discard PDU function. Additionally the adjacency on which the call attempt was placed shall be placed in \u201cFailed\u201d state, and the recall timer set. Until it expires, the IS shall not attempt call establishment for future NPDUs to be forwarded over subnetwork address A, but instead the IS shall invoke the ISO 8473 Discard PDU function.\nWhen the recall timer expires, the IS shall free the adjacency for calls to a different destination or retry attempts to subnetwork address A.\nNOTE 50 If an implementation can store the knowledge of SNPA addresses that have failed along with the time since the attempt was made in a location other than the adjacency on which the call was attempted, then that adjacency can be used for other calls.\n",
    "extraction": []
  },
  {
    "id": 19,
    "title": "8.3.3 Reverse path forwarding on DA circuits\n",
    "text": "Where a subdomain is attached to a Connection-oriented subnetwork by two or more SNPAs, the destination NSAP addresses within the subdomain may be chosen to be constructed from the address of one of the points of attachment. (It need not be. The whole subdomain could be multi-homed by using both SNPA addresses, or some other IDP could be chosen; e.g. ISO DCC.) Traffic to the subdomain from some other SNPA will cause a call to be established to the SNPA corresponding to the destination NSAP\n address in the subdomain. Traffic from the subdomain may use either of the SNPAs depending on the routeing decisions made by the subdomain. This is illustrated in figure 6.\nThe subdomain is attached to the connection-oriented subnetwork via SNPAs A and B. The addresses on the subdomain are constructed using the SNPA address of B as the IDI. If traffic for C.z is sent from B.x, a call will be established from A to C. The reverse traffic from C.z to B.x will cause another call to be established from C to B. Thus two SVCs have been established where only one is required.\nThis problem is prevented by the local system retaining a cache (known as the ReversePathCache) of NSAP addresses from which traffic has been received over each adjacency. When it has traffic to forward over the connection-oriented subnetwork, the IS shall it first check to see if the destination NSAP is in the cache of any of its adjacencies, and if so forwards the traffic over that adjacency. An NSAP shall only be added to the cache when the remote SNPA address of the adjacency over which it is received differs from the SNPA address to be called which would be generated by checking against the Circuit Reachable Addresses managed objects. If the cache is full, the IS shall overwrite the least recently used entry. The ReversePathCache, if implemented, shall have a size of at least one entry. The IS shall purge the cache when the adjacency is taken down (i.e. when the reserveTimer expires).\nFigure 6 - Example of reverse path forwarding\n",
    "extraction": []
  },
  {
    "id": 20,
    "title": "8.3.4 Use of ISO 9542 on ISO 8208 subnetworks\n",
    "text": "Static and DA circuits are equivalent to point-to-point links, and as such permit the operation of ISO 9542 as described for point-to-point links in 8.2.\nFor DA circuits, it is impractical to use ISO 9542 to obtain configuration information, such as the location of Intermediate systems, since this would require calls to be established to all possible SNPA addresses.\nThe IS shall not send ISO 9542 ISH PDUs on a DA circuit. The IS shall take no action on receipt of an ESH PDU or ISH PDU, and the circuit shall complete initialisation without waiting for their arrival.\nThe IS shall not send Point-to-point IIH PDU on DA circuits.\nThe IS shall ignore receipt of point-to-point IIH PDUs on DA circuits.\n",
    "extraction": []
  },
  {
    "id": 21,
    "title": "8.3.5 Interactions with the update process\n",
    "text": "A dynamically assigned circuit contains a list of <reachable address prefix, cost, SNPA address> tuples. Also, each dynamically assigned circuit has a specified call establishment cost measured by callEstablishmentMetrick (where k indexes the four defined metrics). The call establishment cost is always an internal metric, and is therefore directly comparable with the reachable address metric only if the reachable address metric is also internal.\nWhen the circuit is enabled, the Subnetwork Dependent functions in an Intermediate system shall report (to the Update Process) \u201cadjacency cost change\u201d events for all address prefixes in the circuit reachable address managed object, together with the reachable address metric k + Deltak increment. If reachable address metrick is internal, then Deltak = callEstab- lishmentMetrick . If reachable address metrick is external, then\nDeltak = 0\nThis causes this information to be included in subsequently generated LSPs as described in 7.3.3.2. Routeing PDUs (LSPs and Sequence number PDUs) shall not be sent on dynamically assigned circuits.\nNOTE 51 In the following sub-clauses, it is assumed that the Reachable Addresses referenced are only those which have been enabled (i.e. that have state \u201cOn\u201d), and whose parent circuit is also in state \u201cOn\u201d.\n",
    "extraction": []
  },
  {
    "id": 22,
    "title": "8.3.5.1 Adjacency creation\n",
    "text": "After an SVC to SNPA address D is successfully established and a new adjacency created for it (whether it was initiated by the local or the remote system), if callEstablishment-MetrickIncrement is greater than 0, the IS shall scan the circuit Reachable Address managed objects for all addressPrefixes listed with D as (one of) the sNPAAddress(es).\nFor Reachable Addresses with mappingType \u201cAlgorithm\u201d, the IS shall construct an implied address prefix1) from the actual remote SNPA address D and the address extraction algorithm. The IS shall generate an Adjacency cost change event for each such address prefix (both actual and implied) with the Reachable Address metrick (without the added callEstablishment- MetrickIncrement). This causes information that those address prefixes are reachable with the lower cost to be included in subsequently generated LSPs. The effect of this is to encourage the use of already established SVCs where possible.\n",
    "extraction": []
  },
  {
    "id": 23,
    "title": "8.3.5.2 Adjacency deletion\n",
    "text": "When the adjacency with sNPAAddress D is freed (reserveTimer has expired, or the adjacency is deleted by System Management action) then if callEstablishment-MetrickIncrement is greater than 0, the IS shall scan the Circuit Reachable Address managed objects for all those with mappingType explicit and (one of) their sNPAAddresses equal to D. The IS shall generate \u201cAdjacency cost change\u201d events to the Update Process for all such address prefixes with the Reachable Address metrick + Deltak increment (where Deltak is the same as defined above). For Reachable Addresses with an algorithmic extraction mappingType for which it is possible to construct an implied address prefix as above, the IS shall generate an adjacencyStateChange\u201d event for that implied prefix.\nA cost change event shall only be generated when the count of the number of subnetwork addresses which have an established SVC changes between 1 and 0.\n",
    "extraction": []
  },
  {
    "id": 24,
    "title": "8.3.5.3 Circuit call establishment increment change\n",
    "text": "On a dynamically assigned circuit, when system management changes the Circuit callEstablishmentMetrickIIncrement for that circuit, the IS shall generate \u201cadjacency cost change events\u201d for all address prefixes affected by the change (i.e. those for which calls are not currently \u201cestablished\u201d).\nThe IS shall scan all the Reachable Address managed objects of that Circuit. If the Reachable Address has an algorithmic\nextraction mappingType, the IS shall generate an \u201cadjacency cost change\u201d event for that adjacencyId with the Reachable Address metrick + the new value of Deltak . If (based on the new value of callEstablishmentMetrickIncrement) the Reachable Address has mappingType \u201cexplicit\u201d, the IS shall scan all the adjacencies of the circuit for an adjacency with sNPAAddress equal to (one of) the sNPAAddresses of that Reachable Address. If no such adjacency is found the IS shall generate an \u201cadjacency cost change\u201d event for that adjacencyId with the reachable address metrick + the new value of Deltak (based on the new value of callEstablishmentMetrickIncrement).\n",
    "extraction": []
  },
  {
    "id": 25,
    "title": "8.3.5.4 Reachable address cost change\n",
    "text": "When the metrick attribute of a reachableAddress in operationalState \u201cEnabled\u201d is changed by system management, the IS shall generate cost change events to the Update process to reflect this change.\n1) i.e. some address prefix which matches the addressPrefix of the Reachable Address, and which would generate the SNPA Address D when the extraction algorithm is applied.\nIf the reachableAddress has mappingType \u201cexplicit\u201d, the IS shall scan all the adjacencies of the circuit for an adjacency with sNPAAddress equal to (one of) the sNPAAddresses of that reachable address. If one or more such adjacencies are found, the IS shall generate an adjacencyCostChange event for that reachableAddressId with the new reachable address metrick. If no such adjacency is found the IS shall generate an \u201cadjacency cost change\u201d event for that reachableAddressId with the new reachable address metrick.\nIf the reachableAddress has an algorithmic extraction mappingType, the IS shall generate an adjacencyCostChange event for that name with the new reachable address metrick + Deltak (based on the new value of callEstablishment- MetrickIncrement). In addition, for all adjacencies of the circuit with an sNPAAddress for which an implied address prefix can be generated for this reachable address, the IS shall generate an adjacencyCostChange event for that implied address prefix and the new reachable address metrick.\n",
    "extraction": []
  },
  {
    "id": 26,
    "title": "8.3.5.5 Disabling a reachable address\n",
    "text": "When a reachableAddress managed object is disabled via management action, the IS shall generate an adjacency-Down event to the Update process for the adjacencyId of that reachable address and also for any implied prefixes associated with that reachable address.\n",
    "extraction": []
  },
  {
    "id": 27,
    "title": "8.3.5.6 Enabling a reachable address\n",
    "text": "When a reachableAddress is enabled via system management action, the IS shall generate adjacencyCostChange events as described for reachable address cost changes in 8.3.5.4 above.\n",
    "extraction": []
  },
  {
    "id": 28,
    "title": "8.4 Broadcast subnetworks\n",
    "text": "",
    "extraction": []
  },
  {
    "id": 29,
    "title": "8.4.1 Enabling of broadcast circuits\n",
    "text": "When the broadcast circuit is enabled on an Intermediate system the IS shall perform the following actions.\na) Commence sending IIH PDUs with the LAN ID field set to the concatenation of its own systemID and its locally assigned one octet Local Circuit ID.\nb) Solicit the End system configuration as described in 8.4.6\nc) Start listening for ISO 9542 ESH PDUs and acquire adjacencies as appropriate. Do not run the Designated Intermediate System election process.\nd) After waiting iSISHelloTimer \u00d7 2 seconds, run the Level 1 and or the level 2 designated intermediate system election process depending on the Intermediate system type.\n",
    "extraction": []
  },
  {
    "id": 30,
    "title": "8.4.2 Broadcast subnetwork IIH PDUs\n",
    "text": "All Intermediate systems on broadcast circuits (both Level 1 and Level 2) shall transmit LAN IIH PDUs as described in 8.4.4. Level 1 Intermediate systems shall transmit only Level 1 LAN IIH PDUs. Level 2 Intermediate Systems on circuits with manualL2OnlyMode set to the value \u201cTrue\u201d, shall transmit only Level 2 LAN IIH PDUs. Level 2 Intermediate systems on circuits with manualL2OnlyMode set to the value \u201cFalse\u201d, shall transmit both.\nLevel n LAN IIH PDUs contain the transmitting Intermediate system\u2019s ID, holding timer, Level n Priority and manual- AreaAddresses, plus a list containing the lANAddresses of all the adjacencies of neighbourSystemType \u201cLn Intermediate System\u201d (in adjacencyState \u201cInitialising\u201d or \u201cUp\u201d) on this circuit.\nThe Circuit Type field shall be set according to Table 4. In a level 1 IIH PDU the Circuit Type shall be either 1 or 3. In a level 2 IIH PDU the Circuit Type shall be either 2 or 3.\nLAN IIH PDUs shall be padded (with trailing PAD option fields containing arbitrary valued octets) so that the SNSDU containing the IIH PDU has a length of at least maxsize - 1 octets1) where maxsize for Level 1 IIH PDUs is the maximum of\n- dataLinkBlocksize\n- originatingL1LSPBufferSize\n1) The minimum length of PAD which may be added is 2 octets, since that is the size of the option header.  Where possible the PDU should be padded to maxsize, but if the PDU length is maxsize-1 octets no padding is possible (or required).\nand for Level 2 IIH PDUs is the maximum of\n- dataLinkBlocksize\n- originatingL2LSPBufferSize\nThis is done to ensure that an adjacency will only be formed between systems which are capable of exchanging PDUs of length up to maxsize octets. In the absence of this check, it would be possible for an adjacency to exist with a lower maximum block size, with the result that some LSPs and SNPs (i.e. those longer than this maximum, but less than maxsize) would not be exchanged.\nNOTE 52 An example of a topology where this could occur is one where an extended LAN is constructed from LAN segments with  different maximum block sizes. If, as a result of mis-configuration or some dynamic reconfiguration, a path exists between two Intermediate systems on separate LAN segments having a large maximum block size, which involves transit of a LAN segment with a smaller maximum block size, loss of larger PDUs will occur if the Intermediate systems continue to use the larger maximum block size. It is better to refuse to bring up the adjacency in these circum-stances.\nLevel 1 Intermediate systems shall transmit Level 1 LAN IIH PDUs to the multi-destination address AllL1ISs, and also listen on that address. They shall also listen for ESH PDUs on the multi-destination address AllIntermediateSystems. The list of neighbour Intermediate systems shall contain only Level 1 Intermediate Systems within the same area. (i.e. Adjacencies of neighbourSystemType \u201cL1 Intermediate System\u201d.)\nLevel 2 Only Intermediate systems (i.e. Level 2 Intermediate systems which have the Circuit with an associated linkage manualL2OnlyMode characteristic set to the value \u201cTrue\u201d) shall transmit Level 2 LAN IIH PDUs to the multi-destination address AllL2ISs, and also listen on that address. The list of neighbour Intermediate systems shall contain only Level 2 Intermediate systems. (i.e. adjacencies of neighbourSystemType \u201cL2 Intermediate System\u201d.)\nLevel 2 Intermediate systems (with manualL2OnlyMode \u201cFalse\u201d) shall perform both of the above actions. Separate Level 1 and Level 2 LAN IIH PDUs shall be sent to the multi-destination addresses AllL1ISs and AllL2ISs describing the neighbour Intermediate systems for Level 1 and Level 2 respectively. Separate adjacencies shall be created by the receipt of Level 1 and Level 2 LAN IIH PDUs.\n",
    "extraction": []
  },
  {
    "id": 31,
    "title": "8.4.2.1 IIH PDU acceptance tests\n",
    "text": "On receipt of a Broadcast IIH PDU, perform the following PDU acceptance tests:\na) If the IIH PDU was received over a circuit whose externalDomain attribute is \u201cTrue\u201d, the IS shall discard the PDU.\nb) If the ID Length field of the PDU is not equal to the value of the IS\u2019s routeingDomainIDLength, the PDU shall be discarded and an iDFieldLengthMismatch event generated.\nc) If the value of circuitTransmitPassword or the set of circuitReceivePasswords for this circuit is non-null, then perform the following tests:\n1) If the PDU does not contain the Authentication Information field then the PDU shall be discarded and an\nauthenticationFailure event generated.\n2) If the PDU contains the Authentication Information field, but the Authentication Type is not equal to \u201cPassword\u201d, then\ni. If the IS implements the authentication procedure indicated by the Authentication Type whether the IS accepts or ignores the PDU is outside the scope of this International Standard.\nii. If the IS does not implement the authentication procedure indicated by the Authentication Type then the IS shall ignore the PDU and generate an authenticationFailure event.\u201d\n3) Otherwise, the IS shall compare the password in the received PDU with the passwords in the set of circuitReceivePasswords for the circuit on which the PDU was received. If the value in the PDU matches any of these passwords, the IS shall accept the PDU for further processing. If the value in the PDU does not match any of the circuitReceivePasswords, then the IS shall ignore the PDU and generate an authenticationFailure event.\n",
    "extraction": []
  },
  {
    "id": 32,
    "title": "8.4.2.2 Receipt of level 1 IIH PDUs\n",
    "text": "On receipt of a Level 1 LAN IIH PDU on the multi-destination address AllL1ISs, the IS shall perform the following tests:\na) Compare each of the area addresses, from the Area Addresses field of the received IIH PDU with the set of area addresses in the manualAreaAddresses attribute. If a match is not found between any pair (i.e. the local and remote system have no area address in common), the IS shall reject the adjacency and generate an areaMismatch event.\nb) if the Maximum Area Addresses field of the PDU is not equal to the value of the IS\u2019s maximumAreaAddresses then the PDU shall be discarded and a maximumArea-AddressesMismatch event generated, unless the IS only implements a value of three for maximumAreaAddresses, in which case this check may be omitted. If the above tests succeed, the IS shall accept the adjacency and set the Adjacency neighbourSystemType to \u201cL1 Intermediate System\u201d.\n",
    "extraction": []
  },
  {
    "id": 33,
    "title": "8.4.2.3 Receipt of Level 2 IIH PDUs\n",
    "text": "On receipt of a Level 2 LAN IIH PDU on the multi-destination address AllL2ISs, the IS shall accept the adjacency, and set the Adjacency neighbourSystemType to \u201cL2 Intermediate System\u201d.\n",
    "extraction": []
  },
  {
    "id": 34,
    "title": "8.4.2.4 Existing adjacencies\n",
    "text": "When a Level n LAN IIH PDU (Level 1 or Level 2) is received\nfrom an Intermediate system for which there is already an adjacency with\na) the adjacency neighbourSNPAAddress equal to the MAC Source address of the PDU, and\nb) the Adjacency neighbourSystemID equal to the Source ID field from the PDU and\nc) the neighbourSystemType equal to \u201cLn Intermediate System\u201d, the IS shall update the holdingTimer, priorityOfNeighbour and areaAddressesOfNeigh-bour according to the values in the PDU.\n",
    "extraction": []
  },
  {
    "id": 35,
    "title": "8.4.2.5 New adjacencies\n",
    "text": "",
    "extraction": []
  },
  {
    "id": 36,
    "title": "8.4.2.5.1",
    "text": " When a) Level n LAN IIH PDU (Level 1 or Level 2) is received (from Intermediate system R), and\nb) there is no adjacency for which the adjacency neighbourSNPAAddress is equal to the MAC Source address of the PDU; and\nthe IS shall create a new adjacency. However, if there is insufficient space in the adjacency database, to permit the creation of a new adjacency the IS shall instead perform the actions described in 8.4.3.\nThe IS shall\na) set neighbourSystemType to \u201cLn Intermediate System\u201d (where n is the level of the IIH PDU),\nb) set the holdingTimer, priorityOfNeighbour, neighbour-SystemID and areaAddressesOfNeighbour according to the values in the PDU., and\nc) set the neighbourSNPAAddress according to the MAC source address of the PDU.\nThe IS shall set the adjacencyState of the adjacency to \u201cinitialising\u201d, until it is known that the communication between this system and the source of the PDU (R) is two-way. However R shall be included in future Level n LAN IIH PDUs transmitted by this system.\nWhen R reports the local system\u2019s SNPA address in its Level n LAN IIH PDUs, the IS shall\nd) set the adjacency\u2019s adjacencyState to \u201cUp\u201d, and\ne) generate an adjacencyStateChange (Up)\u201d event.\n",
    "extraction": [
      {
        "id": 0,
        "text": "When R reports the local system\u2019s SNPA address in its Level n LAN IIH PDUs, the IS shall d) set the adjacency\u2019s adjacencyState to \u201cUp\u201d, and e) generate an adjacencyStateChange (Up)\u201d event.",
        "present_state": [
          "Unknown",
          "Unknown"
        ],
        "condition": [
          "When R reports the local system\u2019s SNPA address in its Level n LAN IIH PDUs",
          "When R reports the local system\u2019s SNPA address in its Level n LAN IIH PDUs"
        ],
        "new_state": [
          "Up",
          "adjacencyStateChange (Up)"
        ]
      }
    ]
  },
  {
    "id": 37,
    "title": "8.4.2.5.2",
    "text": " The IS shall keep a separate holding time (adjacency holdingTimer) for each \u201cLn Intermediate System\u201d adjacency. The value of holdingTimer shall be set to the holding time as reported in the Holding Time field of the Level n LAN IIH PDUs. If a neighbour is not heard from in that time, the IS shall a) purge it from the database; and\nb) generate an adjacencyStateChange (Down) event.\n",
    "extraction": [
      {
        "id": 0,
        "text": "If a neighbour is not heard from in that time, the IS shall a) purge it from the database; and b) generate an adjacencyStateChange (Down) event.",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "If a neighbour is not heard from in that time"
        ],
        "new_state": [
          "adjacencyStateChange (Down)"
        ]
      }
    ]
  },
  {
    "id": 38,
    "title": "8.4.2.5.3",
    "text": " If a Level n LAN IIH PDU is received from neighbour N, and this system\u2019s lANAddress is no longer in N\u2019s IIH PDU, the IS shall a) set the adjacency\u2019s adjacencyState to \u201cinitialising\u201d, and\nb) generate an adjacencyStateChange (Down) event.\n",
    "extraction": [
      {
        "id": 0,
        "text": "If a Level n LAN IIH PDU is received from neighbour N, and this system\u2019s lANAddress is no longer in N\u2019s IIH PDU, the IS shall a) set the adjacency\u2019s adjacencyState to \u201cinitialising\u201d, and b) generate an adjacencyStateChange (Down) event.",
        "present_state": [
          "Unknown",
          "Unknown"
        ],
        "condition": [
          "If a Level n LAN IIH PDU is received from neighbour N, and this system\u2019s lANAddress is no longer in N\u2019s IIH PDU",
          "If a Level n LAN IIH PDU is received from neighbour N, and this system\u2019s lANAddress is no longer in N\u2019s IIH PDU"
        ],
        "new_state": [
          "Initialising",
          "adjacencyStateChange (Down)"
        ]
      }
    ]
  },
  {
    "id": 39,
    "title": "8.4.3 Insufficient space in adjacency database\n",
    "text": "If an IS needs to create a new Intermediate system adjacency, but there is insufficient space in the adjacency database, the adjacency of neighbourSystemType \u201cLn Intermediate System\u201d with lowest l x intermediateSystemPriority (or if more than one adjacency has the lowest priority, the adjacency with the lowest SNPAAddress, from among those with the lowest priority) shall be purged from the database. If the new adjacency would have the lowest priority, it shall be ignored, and a rejectedAdjacency event generated.\nIf an old adjacency must be purged, the IS shall generate an adjacencyStateChange (Down) event for that adjacency. After the Subnetwork Independent Functions issue an \u201cadjacency down complete\u201d, the IS may create a new adjacency.\n",
    "extraction": [
      {
        "id": 0,
        "text": "If an old adjacency must be purged, the IS shall generate an adjacencyStateChange (Down) event for that adjacency.",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "If an old adjacency must be purged"
        ],
        "new_state": [
          "adjacencyStateChange (Down)"
        ]
      }
    ]
  },
  {
    "id": 40,
    "title": "8.4.4 Transmission of LAN IIH PDUs\n",
    "text": "A Level 1 IS shall transmit a Level 1 LAN IIH PDU immediately when any circuit whose externalDomain attribute is \u201cFalse\u201d has been enabled. A Level 2 Intermediate System shall transmit a Level 2 LAN IIH PDU. A Level 2 Intermediate System shall also transmit a Level 1 LAN IIH PDU unless the circuit is marked as manualL2OnlyMode \u201cTrue\u201d.\nThe IS shall also transmit a LAN IIH PDU when at least 1 second has elapsed since the last transmission of a LAN IIH PDU of the same type on this circuit by this system and:\na) iSISHelloTimer seconds have elapsed1) since the last periodic LAN IIH PDU transmission.\nThe Holding Time is set to ISISHoldingMultiplier \u00d7 iSISHelloTimer. For a Designated Intermediate System the value of dRISISHelloTimer2) is used instead of iSISHelloTimer. The Holding Time for this PDU shall therefore be set to ISISHoldingMultiplier \u00d7 dRISIS-HelloTimer seconds. This permits failing Designated In-termediate Systems to be detected more rapidly,\nor\nb) the contents of the next IIH PDU to be transmitted would differ from the contents of the previous IIH PDU transmitted by this system, or\nc) this system has determined that it is to become or resign as LAN Designated Intermediate System for that level.\nTo minimise the possibility of the IIH PDU transmissions of all Intermediate systems on the LAN becoming synchronised, the hello timer shall only be reset when a IIH PDU is transmitted as a result of timer expiration, or on becoming or resigning as Designated Intermediate System.\nWhere an Intermediate system is transmitting both Level 1 and Level 2 LAN IIH PDUs, it shall maintain a separate timer (separately jittered) for the transmission of the Level 1 and Level 2 IIH PDUs. This avoids correlation between the Level 1 and Level 2 IIH PDUs and allows the reception buffer requirements to be minimised.\nIf the value of the circuitTransmitPassword for the circuit is non-null, then the IS shall include the Authentication Information field in the transmitted IIH PDU, indicating an Authentication Type of \u201cPassword\u201d and containing the circuitTransmitPassword as the authentication value.\n",
    "extraction": []
  },
  {
    "id": 41,
    "title": "8.4.5 LAN designated intermediate systems\n",
    "text": "A LAN Designated Intermediate System is the highest priority Intermediate system in a particular set on the LAN, with numerically highest MAC source SNPAAddress breaking ties. (See 7.1.8 for how to compare LAN addresses.)\n1) Jitter is applied as described in 10.1.\n2) In this case jitter is not applied, since it would result in intervals of less than one second.\nThere are, in general, two LAN Designated Intermediate Systems on each LAN, namely the LAN Level 1 Designated Intermediate System and the LAN Level 2 Designated Intermediate System. They are elected as follows.\na) Level 1 Intermediate systems elect the LAN Level 1 Designated Intermediate System.\nb) Level 2 Only Intermediate systems (i.e. Level 2 Intermediate Systems which have the Circuit manualL2OnlyMode\ncharacteristic set to the value \u201cTrue\u201d) elect the LAN Level 2 Designated Intermediate System.\nc) Level 2 Intermediate systems (with manualL2OnlyMode \u201cFalse\u201d) elect both the LAN Level 1 and LAN Level 2 Designated Intermediate Systems.\nThe set of Intermediate systems to be considered includes the local Intermediate system, together with all Intermediate systems of the appropriate type as follows.\nd) For the LAN Level 1 Designated Intermediate System, it is the set of Intermediate systems from which LAN Level 1 IIH PDUs are received and to which Level 1 adjacencies exist in adjacencyState \u201cUp\u201d. When the local system either becomes or resigns as LAN Level 1 Designated Intermediate System, the IS shall generate a lANLevel1DesignatedIntermediateSystemChange event. In addition, when it becomes LAN Level 1 Designated Intermediate System, it shall perform the following actions.\n1) Generate and transmit Level 1 pseudonode LSPs using the existing End system configuration.\n2) Purge the Level 1 pseudonode LSPs issued by the previous LAN Level 1 Designated Intermediate System (if any) as described in 7.2.3.\n3) Solicit the new End system configuration as described in 8.4.6.\ne) For the LAN Level 2 Designated Intermediate System, it is the set of Intermediate systems from which LAN Level 2 IIH PDUs are received and to which Level 2 adjacencies exist in adjacencyState \u201cUp\u201d. When the local system either becomes or resigns as LAN Level 2 Designated Intermediate System, the IS shall generate a lANLevel2DesignatedIntermediateSystemChange event. In addition, when it becomes LAN Level 2 Designated Intermediate System, it shall perform the following actions.\n1) Generate and transmit a Level 2 pseudonode LSP.\n2) Purge the Level 2 pseudonode LSPs issued by the previous LAN Level 2 Designated Intermediate System (if any) as described in 7.2.3.\nWhen an Intermediate system resigns as LAN Level 1 or Level 2 Designated Intermediate System it shall perform the actions on Link State PDUs described in 7.2.3.\nThe IS shall run the Level 1 and/or the Level 2 Designated Intermediate System election process (depending on the Intermediate system type) whenever an IIH PDU is received or transmitted as described in 8.4.4. (For these purposes, the transmission of the system\u2019s own IIH PDU is equivalent to receiving it). If there has been no change to the information on which the election is performed since the last time it was run, the previous result can be assumed. The relevant information is\nf) the set of Intermediate system adjacency states;\ng) the set of Intermediate System priorities (including this system\u2019s); and\nh) the existence (or otherwise) of at least one \u201cUp\u201d End system (not including manual adjacencies) or Intermediate system adjacency on the circuit.\nAn Intermediate system shall not declare itself to be a LAN Designated Intermediate system of any type until it has at least one \u201cUp\u201d End system (not including manual adjacencies) or Intermediate system adjacency on the circuit. (This prevents an Intermediate System which has a defective receiver and is incapable of receiving any PDUs from erroneously electing itself LAN Designated Intermediate System.)\nThe LAN ID field in the LAN IIH PDUs transmitted by this system shall be set to the value of the LAN ID field reported in the LAN IIH PDU (for the appropriate level) received from the system which this system considers to be the Designated Intermediate System. This value shall also be passed to the Update Process, as the pseudonode ID, to enable Link State PDUs to be issued for this system claiming connectivity to the pseudonode.\nIf this system, as a result of the Designated Intermediate System election process, considers itself to be designated Intermediate System, the LAN ID field shall be set to the concatena\\tion of this system\u2019s own system ID and the locally assigned one octet Local Circuit ID.\n",
    "extraction": []
  },
  {
    "id": 42,
    "title": "8.4.6 Soliciting the ES configuration\n",
    "text": "When there is a change in the topology or configuration of the LAN (for example the partitioning of a LAN into two segments by the failure of a repeater or bridge), it is desirable for the (new) Designated Intermediate System to acquire the new End system configuration of the LAN as quickly as possible in order that it may generate Link State PDUs which accurately reflect the actual configuration. This is achieved as follows.\nWhen the circuit is enabled, or the Intermediate system detects a change in the set of Intermediate systems on the LAN, or a change in the Designated Intermediate System ID, the IS shall initiate a poll of the ES configuration by performing the following actions.\na) Delay a random interval between 0 and iSISHelloTimer. (This is to avoid synchronisation with other Intermediate systems which have detected the change.)\nb) If (and only if) an Intermediate System had been removed from the set of Intermediate systems on the LAN,\nreset the entryRemainingTime field in the neighbour-SystemIDs adjacency database record of all adjacencies on this circuit to the value\n(iSISHelloTimer + pollESHelloRate) \u00d7 iSISHoldingMultiplier\nor the existing value whichever is the lower. (This causes any End systems which are no longer present on the LAN to be rapidly timed out, but not before they have a chance to respond to the poll.)\nc) Transmit iSISHoldingMultiplier ISH PDUs for each NET possessed by the Intermediate system with a Suggested ES Configuration Timer value of pollESHelloRate at an interval between them of iSISHelloTimer and a holding time of iSConfigurationTimer \u00d7 iSISHoldingMultiplier.\nd) Resume sending ISH PDUs at intervals of iSConfiguration-Timer with a Suggested ES Configuration Timer value of\ndefaultESHelloTimer.\n",
    "extraction": []
  },
  {
    "id": 43,
    "title": "8.4.7 Receipt of ESH PDUs \u2014 database of end systems\n",
    "text": "An IS shall enter an End system into the adjacency database when an ESH PDU is received from a new data link address. If an ESH PDU is received with the same data link address as a current adjacency, but with a different NSAP address, the new address shall be added to the adjacency, with a separate timer. A single ESH PDU may contain more than one NSAP address. When a new data link address or NSAP address is added to the adjacency database, the IS shall generate an adjacencyStateChange (Up) event on that adjacency.\nThe IS shall set a timer for the value of the Holding Time field in the received ESH PDU. If another ESH PDU is not received from the ES before that timer expires, the ES shall be purged from the database, provided that the Subnetwork Independent Functions associated with initialising the adjacency have been completed. Otherwise the IS shall clear the adjacency as soon as those functions are completed.\nWhen the adjacency is cleared, the Subnetwork Independent Functions shall be informed of an adjacencyStateChange (Down) event, and the adjacency can be re-used after the Subnetwork Independent Functions associated with bringing down the adjacency have been completed.\n",
    "extraction": [
      {
        "id": 0,
        "text": "When a new data link address or NSAP address is added to the adjacency database, the IS shall generate an adjacencyStateChange (Up) event on that adjacency.",
        "present_state": [
          "Unknown"
        ],
        "condition": [
          "When a new data link address or NSAP address is added to the adjacency database"
        ],
        "new_state": [
          "adjacencyStateChange (Up)"
        ]
      }
    ]
  }
]